
#include "mapmerge.h"
#include "math.h"

StitchedMap::StitchedMap(Mat &img1, Mat &img2, float max_pairwise_distance)
{
  // load images, TODO: check that they're grayscale
  image1 = img1.clone();
  image2 = img2.clone();

  // create feature detector set.
  Ptr<FeatureDetector> detector = ORB::create();
  // Ptr<ORB> detector = ORB::create();
  // OrbFeatureDetector detector;
  Ptr<DescriptorExtractor> dexc = ORB::create();
  // OrbDescriptorExtractor dexc;
  BFMatcher dematc(NORM_HAMMING, false);

  // 1. extract keypoints
  detector->detect(image1, kpv1);
  detector->detect(image2, kpv2);

  // 2. extract descriptors
  dexc->compute(image1, kpv1, dscv1);
  dexc->compute(image2, kpv2, dscv2);

  // 3. match keypoints
  dematc.match(dscv1, dscv2, matches);


  // 4. find matching point pairs with same distance in both images
  // for (size_t i=0; i<matches.size(); i++) {
  //   KeyPoint a1 = kpv1[matches[i].queryIdx],
  //            b1 = kpv2[matches[i].trainIdx];

  //   if (matches[i].distance > 30)
  //     continue;

  //   for (size_t j=0; j<matches.size(); j++) {
  //     KeyPoint a2 = kpv1[matches[j].queryIdx],
  //              b2 = kpv2[matches[j].trainIdx];

  //     if (matches[j].distance > 30)
  //       continue;

  //     if ( fabs(norm(a1.pt-a2.pt) - norm(b1.pt-b2.pt)) > max_pairwise_distance ||
  //          fabs(norm(a1.pt-a2.pt) - norm(b1.pt-b2.pt)) == 0)
  //       continue;

  //     coord1.push_back(a1.pt);
  //     coord1.push_back(a2.pt);
  //     coord2.push_back(b1.pt);
  //     coord2.push_back(b2.pt);

  //     fil1.push_back(a1);
  //     fil1.push_back(a2);
  //     fil2.push_back(b1);
  //     fil2.push_back(b2);
  //   }
  // }

  // if (coord1.size() == 0)
  //   ;
  
  // // 5. find homography
  // H = estimateRigidTransform(coord2, coord1, false);
  // // 6. calculate this stuff for information
  // rotation = 180./M_PI*atan2(H.at<double>(0,1),H.at<double>(1,1)),
  // transx   = H.at<double>(0,2),
  // transy   = H.at<double>(1,2);
  // scalex   = sqrt(pow(H.at<double>(0,0),2)+pow(H.at<double>(0,1),2));
  // scaley   = sqrt(pow(H.at<double>(1,0),2)+pow(H.at<double>(1,1),2));
  
}

Mat
StitchedMap::get_debug()
{
  Mat out;
  drawKeypoints(image1, kpv1, image1, Scalar(255,0,0));
  drawKeypoints(image2, kpv2, image2, Scalar(255,0,0));
  drawMatches(image1,fil1, image2,fil2, matches,out,Scalar::all(-1),Scalar::all(-1));
  return out;
}

Mat // return the stitched maps
StitchedMap::get_stitch()
{
  // // create storage for new image and get transformations
  // Mat image(image2.size(), image2.type());
  // // warpAffine(image2,image,H,image.size());
  // double alpha = 0;
  // double beta = ( 1.0 - alpha );
  // // blend image1 onto the transformed image2
  // addWeighted(image, alpha, image1, beta, 1.0, image);
  // // cout << image << endl;
  // return image;
  
  Mat res;
  bitwise_and(image1, image2, res);
  return res;
}

StitchedMap::~StitchedMap() { }
